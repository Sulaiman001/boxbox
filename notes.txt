DOING

------------------------------------------------------------------------------------------------------------------------------

TODO

- world.createBoundaryZone(x1,y1,x2,y2)
- world.destroyBoundaryZone(boundaryZone) -> unbinds any entity binded to this zone
- entity.bindBoundaryZone(boundaryZone, callback) -> execute callback when entity jumps out
- entity.unBindBoundaryZone(boundaryZone)

- world.getWorldCurrentWindowInfos() -> x,y,width,height

- world.focusAll() - recadrer sur tous les objets prÃ©sents dans le world

- special css styles (prevent text select, drag ...)
- mouseWheelZoom
    - maxScale
    - minScale
    - maxWindow : {x1,y1,x2,y2}
    - minWindow : {x1,y1,x2,y2}
- onMouseWheel
- mousePan : include all non draggable entities
    - excludeEntityIds : [id ...] will exclude the entities listed (possible conflicts on events)
- touchPan
    - excludeEntityIds : [id ...] will exclude the entities listed (possible conflicts on events)
    - allowPinch = on a touchmove, when touches.length > 2 && none of touchInfos contains an entity
        - maxScale
        - minScale
        - maxWindow : {x1,y1,x2,y2}
        - minWindow : {x1,y1,x2,y2}
- mouseDraggable/touchDraggable : special joints (not only mouseJoint) - good thing todo ?
- delete destroyed entity handlers
- optimize the for loops
- pass the private attribute inside _ops

- compatibility mouseDraggable -> touchDraggable ?
- draggable : releaseDrag -> release allMouseJoints

- world._getDebugDraw() -> returns a new b2DebugDraw() with the new scale

------------------------------------------------------------------------------------------------------------------------------

DONE

- make an accurate .find(x,y) method => world.getEntityByPosition()
- world
    - onTouchstart(e)
    - onTouchmove(e)
    - onTouchend(e)
    - onTouchcancel(e) -> canceled
- touchOnly
- mouseOnly
-fix the creation of polygon : in the extends method, the length of the array in erased ...


---- DONE --- touchDraggable :

touchDraggable
- options :
    - regularDrag
        - maxTouches
           - allowPinch (later)
    - eventDrag @todo
        - maxTouches
           - allowPinch (later)
    - noMove
    - noRotate
- events :
    - start : function(e,[touchDragInfos, ...],touchIndex)//triggered on touchmove (on the first touch ON the entity)
    - drag : function(e,[touchDragInfos, ...])//triggered on touchmove (on any touch joined to the entity)
    - stop : function(e,[touchDragInfos, ...],touchIndex)//triggered on touchend (on the last touch joined to the entity)
    - touchadd : function(e,[touchDragInfos, ...],touchIndex)//triggered on touchstart (on any touch joined to the entity)
    - touchremove : function(e,[touchDragInfos, ...],touchIndex)//triggered on touchend (on any touch joined to the entity)
 
    queue the drag events so that they will be fired only once per touchmove event

 touchDraggableInfos =
    - touchIdentifier
    - originalPosition = {x,y}
    - position = {x,y}

world._touchDraggingEntityIds[]
entity._touchMoveJoints[touchIdentifier] = {joint,originalPosition}