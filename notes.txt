DOING

------------------------------------------------------------------------------------------------------------------------------

TODO

//later
- world.createBoundaryZone(x1,y1,x2,y2)
- world.destroyBoundaryZone(boundaryZone) -> unbinds any entity binded to this zone
- entity.bindBoundaryZone(boundaryZone, callback) -> execute callback when entity jumps out
- entity.unBindBoundaryZone(boundaryZone)
- world._boundaryZones = {}
- by default, world.restrictStage creates a "world" boundary zone
- entity.onEnterWorld(callback)
- entity.onOutWorld(callback)
- entity.onEnterBoundaryZone(boundaryZoneId,callback)
- entity.onOutBoundaryZone(boundaryZoneId,callback)


- special css styles (prevent text select, drag ...)
- mouseWheelZoom
    - maxScale
    - minScale
    - maxWindow : {x1,y1,x2,y2}
    - minWindow : {x1,y1,x2,y2}
- onMouseWheel
- mousePan : include all non draggable entities
    - excludeEntityIds : [id ...] will exclude the entities listed (possible conflicts on events)
    - start
    - drag
    - stop
- touchPan
    - excludeEntityIds : [id ...] will exclude the entities listed (possible conflicts on events)
    - start
    - drag
    - stop
    - allowPinch = on a touchmove, when touches.length > 2 && none of touchInfos contains an entity
callback infos : viewportInfos :
- originalViewport
- viewport


- mouseDraggable/touchDraggable : special joints (not only mouseJoint) - good thing todo ?
- delete destroyed entity handlers
- optimize the for loops
- pass the private attribute inside _ops

- compatibility mouseDraggable -> touchDraggable ?
- draggable : releaseDrag -> release allMouseJoints

- world._getDebugDraw() -> returns a new b2DebugDraw() with the new scale

- mouseDraggable -> 
     - enable -> add entityId to world._mouseDraggableEntityIds         //done
     - disable -> remove entityId from world._mouseDraggableEntityIds   //done
- touchDraggable -> 
     - enable -> add entityId to world.touchDraggableEntityIds          //done
     - disable -> remove entityId from world.touchDraggableEntityIds    //done

world._addMousePanExcludeEnityId(id)        //done
world._removeMousePanExcludeEnityId(id)     //done
world._addTouchPanExcludeEnityId(id)        //done
world._removeTouchPanExcludeEnityId(id)     //done

//specific excludeEntityId for draggable entitys ? -> no, pick in the list of draggables, use :
_mouseDraggableEntityIds    //done
_touchDraggableEntityIds    //done

-> update these at .mouseDraggable + touchDraggable

world._mousePanStartDrag = true
world._mousePanDragging = originalWindowInfos

regroup apis in world.viewport namespace//done

world.restrictStage({maxWindow,maxScale}) @optional params -> insert it in createWorld
    - top
    - right
    - bottom
    - left
    - maxScale
viewport.check(viewport) return boolean
viewport.resolve(viewport) return viewport

- refactor : use getEntityFromMouse and remove checkPosition from the for loops in the top level handlers//done

------------------------------------------------------------------------------------------------------------------------------

DONE

- make an accurate .find(x,y) method => world.getEntityByPosition()
- world
    - onTouchstart(e)
    - onTouchmove(e)
    - onTouchend(e)
    - onTouchcancel(e) -> canceled
- touchOnly
- mouseOnly
-fix the creation of polygon : in the extends method, the length of the array in erased ...

- world.getWorldCurrentWindowInfos() -> x,y,width,height

- world.focusAll() - recadrer sur tous les objets pr√©sents dans le world

---- DONE --- touchDraggable :

touchDraggable
- options :
    - regularDrag
        - maxTouches
           - allowPinch (later)
    - eventDrag @todo
        - maxTouches
           - allowPinch (later)
    - noMove
    - noRotate
- events :
    - start : function(e,[touchDragInfos, ...],touchIndex)//triggered on touchmove (on the first touch ON the entity)
    - drag : function(e,[touchDragInfos, ...])//triggered on touchmove (on any touch joined to the entity)
    - stop : function(e,[touchDragInfos, ...],touchIndex)//triggered on touchend (on the last touch joined to the entity)
    - touchadd : function(e,[touchDragInfos, ...],touchIndex)//triggered on touchstart (on any touch joined to the entity)
    - touchremove : function(e,[touchDragInfos, ...],touchIndex)//triggered on touchend (on any touch joined to the entity)
 
    queue the drag events so that they will be fired only once per touchmove event

 touchDraggableInfos =
    - touchIdentifier
    - originalPosition = {x,y}
    - position = {x,y}

world._touchDraggingEntityIds[]
entity._touchMoveJoints[touchIdentifier] = {joint,originalPosition}